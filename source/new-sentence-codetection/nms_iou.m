function top = nms_iou(boxes, iou, K)
% Non-maximum suppression.
% Greedily select high-scoring detections and skip detections
% that are significantly covered by a previously selected
% detection.
% NOTE: This is adapted from Pedro Felzenszwalb's version (nms.m)
% NOTE: Adapted from Tomasz Malisiewicz's version found at
% http://www.computervisionblog.com/2011/08/blazing-fast-nmsm-from-exemplar
% -svm.html to use the [x y w h score] boxes generated by edgeBoxes or MCG
% as well as use IoU overlap instead of min overlap.  Had to add back in a
% loop within a loop, but still runs pretty fast.

%%**boxes is numboxes x 5 x numframes matrix

if isempty(boxes)
    top = zeros(K,5,1);
    return;
end

[numboxes,~,numframes] = size(boxes);
top = zeros(K,5,numframes);

parfor t = 1:numframes
    intersection = rectint(boxes(:,1:4,t),boxes(:,1:4,t));
    area = diag(intersection);
    IoU = zeros(size(intersection));
    suppress = [];
    for i = 1:numboxes
        for j = i+1:numboxes
            IoU(i,j) = intersection(i,j)/(area(i)+area(j)-intersection(i,j));
            if IoU(i,j) > iou
                %prefer box with higher score
                if (boxes(j,5) > boxes(i,5))
                    suppress = [suppress i];
                else
                    suppress = [suppress j];
                end
                %             %prefer smaller box
                %             if (area(j) > area(i))
                %                 suppress = [suppress j];
                %             else
                %                 suppress = [suppress i];
                %             end
            end
        end %for j
    end %for i
    %IoU
    %suppress
    keep = 1:numboxes;
    keep(suppress) = [];
    if (length(keep)) < K
        temp_top = zeros(K,5);
        %boxes(pick,:)
        temp_top(1:length(keep),:) = boxes(keep,:,t);
    else
        temp_top(:,:) = boxes(keep(1:K),:,t);
    end
    top(:,:,t) = temp_top;
end % for t
end %function

%GARBAGE--calculates union as a bounding box of the 2 rectangles
% intersectionArea=rectint(gt,pr); %If you don't have this function then write a simple one for yourself which calculates area of intersection of two rectangles.
% unionCoords=[min(x_g,x_p),min(y_g,y_p),max(x_g+width_g-1,x_p+width_p-1),max(y_g+height_g-1,y_p+height_p-1];
% unionArea=(unionCoords(3)-unionCoords(1)+1)*(unionCoords(4)-unionCoords(2)+1);
% overlapArea=intersectionArea/unionArea; %This should be greater than 0.5
% to consider it as a valid detection.
