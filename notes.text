Notes file for object co-detection work

27 Dec 14 
--Starting notes file: general idea for this is 3 steps: 
  1) proposals (machine-detected bounding boxes for objects within images)

  2) similarity measure (a measure of the match between boxed objects in
  successive frames)

  3) graphical model solution (formulate boxes with similarity measures as graph
and then find max score path through graph by some method).

--Beginning with tang2014co paper and associated co-localize-v1 code.  Also have
the other 10 papers on co-detection that Haonan posted to Mendeley.  

--Need to look through robot video to find examples of frames with objects in
the field of view.  Right now just need series of frames of same object, not
necessarily from the same video. 

 -----------------git commit 861b30----------------

5 Jan 15 

--Epoxied tilt servo back onto pan servo gears.  Need to let set for 24 hours, 
  then will reattach camera screw.   

--First attempt at running colocalize-v1 code--had to change algorithm parameter
  in solve_qp.m from 'interior-point-convex' to 'interior-point'.  Not very good
  results on example horse pictures.  Tried on cone images from our rover
  training dataset (MSEE1dataset), got equally poor results.

--Noticed in readme for colocalize-v1 code that it is just an implementation of
  the box model from tang2014co paper--does not implement the image model or the
  saliency prior.  This could explain why results on provided test images are
  poor. 

--Got forests_edges_boxes.zip code from Haonan--used for proposal generation.
  Need to start looking at this code.  Also still need to get similarity measure
  code from Haonan.

--Talking with Dan regarding poor results of colocalize-v1 on our cone images,
  came up with the idea to infer a ground plane in the images based on our
  knowledge of the dimensions of the robot (specifically camera height off
  ground and camera tilt angle).  That should allow us to eliminate detections
  that include the floor itself.  Also discussed how to infer a 3D location for
  an object using the height/size of the object in the image with the (known)
  location of the robot.  Can use the distance from the bottom of the image to
  the bottom of the object box to infer a distance from the robot to the
  object.  With that distance, can infer the object's size based on the
  height/width of the box.  Can use this inferred 3D location to limit object
  box comparisons--only need to check similarity of boxes at the same 3D
  location.  Jeff also mentioned using Optical Flow to also aid in codetection,
  since we know the motion of the robot and can apply that to the images.

 -----------------git commit 699a5c5----------------

7 Jan 15

--Got vlfeat.zip from Haonan, which has his similarity measure.  Started working
  on getting this code running and understanding it.

--Added file edgeBoxesOut.m to ./forests_edges_boxes/.  File was missing from
  original zip file.  Also added it to forests_edges_boxes.zip.

--Followed instructions in the readme.txt in ./forests_edges_boxes/ to install
  required dependencies, such as Piotr's Matlab Toolbox and others, detailed in
  section 3 of the readme.

--Got phow_box_match.m from Haonan's vlfeat.zip running on images of traffic
  cones.  His 'scores' variable is the chi-squared distance between the
  phow_hist of boxes in the two images--ultimately a similarity score (lower =
  better).  This replaces the 5th column of the output of edgeBoxesOut, which is
  the box score (higher = better??).  Need to develop a cost function that uses
  both box and similarity score to relate a pair of boxes to each other.  Then
  can optimize this cost function using OpenGM (LOOK UP!!).

-----------------git commit eb7408d----------------

8 Jan 15 

--Used OpenCV camera calibration to get intrinsic matrix for robot front camera.
  Data is saved in camera_calibration/out_camera_data.xml.  Using that intrinsic
  matrix in Dan's  scheme projection code seems to improve the accuracy of the
  projection, but it is still off a bit.

-----------------git commit ccea402----------------

9 Jan 15

--got rover-projection.sc and toollib-perspective-projection.sc from Dan.  Can
  use pixel-and-height->world in rover-projection.sc to go from a pixel location
  to a world location.  Need to look into matlab->scheme interface in
  darpa-collaboration/ideas/toollib-matlab.

-----------------git commit e4cbb6e----------------

14 Jan 15

--Updated notes and added some papers.

-----------------git commit 49760af----------------

15 Jan 15

--Started working on some MATLAB code to approximate what is in
  rover-projection.sc.  The idea is to use some of the various MATLAB-based
  proposal generators along with the ability to map a pixel to a 3-D point (from
  the Scheme code) to help in the eventual cost function for the similarity
  between object boxes.  Have video imported and broken into frame images, and
  sentence imported.  Next need to work on getting odometry and frame timing
  information into MATLAB in order to associate frames with locations.  Then
  need to get efficient method to find location of proposal box (probably center
  of bottom of box), using the assumption that it is on the ground plane.  This
  assumption won't be always valid, but using it should give us bogus (or at
  least unique) locations for bad boxes.  For good boxes we should get a
  relatively consistent 3-D location for the objects.

--Had to tweak ~/Documents/MATLAB/startup.m to ensure that Piotr's Computer
  Vision Matlab Toolbox (http://vision.ucsd.edu/~pdollar/toolbox/doc/index.html)
  works every time MATLAB starts.  Saved a copy in MATLABstartup.m

--Also downloaded EKFMonoSLAM and two related papers by Civera.  Need to get up
  to speed on these, since at first glance they seem to be doing exactly what
  we're doing.

-----------------git commit 891328a----------------

16 Jan 15

--Started working with EKFMonoSLAM code, trying to adapt it to use our video.
  Having a few problems with getting initial point matches on first iteration of
  main loop--I think it is because we aren't getting enough candidate matches.
  I think I need to either read their papers or dig a little deeper into the
  code in order to figure out how they're doing their thing and see if I can
  adapt the code to our images.  Already had to make a few mods, so have virgin
  copy of code in ~/Downloads/EKF...

-----------------git commit 73de280----------------

22 Jan 15

--More work on getting EKFMonoSLAM code to work with our videos.  I think I need
  to get a camera calibration with our camera that is compatible with their
  format.  Still working on this.

-----------------git commit ef63018----------------

23 Jan 15

--Redid OpenCV camera calibration using PPM images instead of JPGs.  Tried
  calibration with a varying number of images to use for calibration.  Saved
  each in camera_calibration/out_camera_data_#ppms.xml.  Ended up getting the
  best results (judged by wall/door lines in background being parallel) from the
  least number of images, 25.  Higher numbers had significant curvature in lines
  that should have been straight.  Next step is to take calibration output and
  figure out how to convert it into the format used by EKFMonoSLAM.
--Figured out the mapping between the OpenCV camera parameters and the
  parameters in the Bouguet model, which is the one that the EKFMonoSLAM code
  can convert from into their model using the code in
  EKF_monoSLAM_1pRANSAC/matlabcalibration2ourcalibration/Bouguet2Tsai.m.
  Original data is saved in matlab_calibration.mat and output saved in
  my_cam_params.m, both in the above directory.
--Got EKFMonoSLAM to start working by doubling the window sizes in
  initialize_a_feature.m (since original code was meant for 320x240 images and
  we have 640x480).  It runs for a few steps and then starts throwing the
  same error it was before--when in select_random_match.m, tries to index an
  element of positions_individually_compatible but can't because
  numel(positions_individually_compatible)=0. I need to figure out why it
  doesn't find any positions that are compatible between frames.

-----------------git commit 6ad0f80----------------


Email to Jeff 27 Jan 15

I'm making progress.  I got the camera calibration and image size (they were
using 320x240 images, and ours are 640x480, so I had to find and change a number
of hard-coded parameters) issues figured out and now I can run their code on our
videos.

The problem I'm running into now is that the code runs for a few frames and then
hits an error.  If I'm interpreting the error message correctly, what's
happening is that it's not finding enough potential matches between the interest
points detected in the two frames.  That is critical to their algorithm because
they are using just the images to localize the camera.  However, since we have
odometry data to work with, that's not as important to us.  Since we can
localize the camera, the rough estimates of where a point is in relation to the
camera can be useful.

What I'm trying to do now is look within the data structures they use to find
the location (presumably with error) estimates for interest points that they
come up with via their algorithm.  Since I'll just be using these to trim the
number of proposals, I don't think I need anything terribly accurate--I just
want to be able to reject proposals that are clearly above or below the ground
plane.


Reply from Jeff 28 Jan 15

   The problem I'm running into now is that the code runs for a few frames and
   then hits an error.  If I'm interpreting the error message correctly, what's
   happening is that it's not finding enough potential matches between the
   interest points detected in the two frames.  That is critical to their
   algorithm because they are using just the images to localize the camera.

I'm not sure I understand how doing what appears below addresses the issue
raised above.

   However, since we have odometry data to work with, that's not as important to
   us.  Since we can localize the camera, the rough estimates of where a point
   is in relation to the camera can be useful.

   What I'm trying to do now is look within the data structures they use to find
   the location (presumably with error) estimates for interest points that they
   come up with via their algorithm.  Since I'll just be using these to trim the
   number of proposals, I don't think I need anything terribly accurate--I just
   want to be able to reject proposals that are clearly above or below the
   ground plane.

Are you saying that

 1. You are not going to run their full algorithm. That their algorithm has two
    parts or stages. The first works and the second doesn't. So you are going to
    discard the second and just use the first because that is all you need?

or

 2. Part of their algorithm fails. And you will replace or augment that part
    with odemtry data and attempt to run their full algorithm with this change?

    Jeff (http://engineering.purdue.edu/~qobi)


My reply to Jeff 28 Jan 15

I was trying to describe something like 1, where I would use parts of their
algorithm to get additional data to use with proposals and similarity measures.

However, after digging deeper into their code and talking with Dan yesterday,
I've decided to put the monocular SLAM aside for now.  Their code is simply too
opaque for me to easily find the data that I'm looking for.  As you said before,
it's starting to become a rabbit hole.

What I'm going to try instead is to use the code that Dan and I came up with a
few weeks ago (where we were projecting the lines and shapes onto the video) to
extract more data from the images in order to build additional similarity
measures.

The general idea is this: (Dan, please jump in if you see anything I missed in
what we discussed yesterday)

1) Get proposal boxes from one of the various proposal mechanisms we have.

2) Use our code, along with the assumption that the bottom of the proposal box
rests on the ground plane, to determine a world location for the box.  I know
that the assumption will be invalid for some boxes, but those boxes will still
get a world location. We can then use the known boundaries of our driving area
to eliminate proposals that are outside our boundaries.  That should do roughly
half of what I was trying to do with the monocular SLAM part.

3) For the boxes that remain after this cut, do 3 different similarity measures:
    1) Visual similarity (what the default similarity measures use) 
    2) Location similarity (from 2 above) 
    3) Object size similarity--like in 2, we can also compute the world height
    and width of a box once we know its distance from the camera.  The thought
    here is that boxes that surround the same object should be more similar in
    size than two random boxes. 

4) These 3 similarity measures should give us a reasonable amount of data to
work with when formulating the graphical model.  Once we have the model
formulated and have boxes grouped into clusters that represent the same object,
we can then use some sort of average of the locations of those boxes to
determine the object location.

We also considered that we will probably get a lot of proposal boxes that detect
the ground right in front of the rover.  These will not get rejected by 2
because they will be in bounds.  While these boxes will probably get high visual
similarity, I doubt that size and location similarity will be very high.  But
should these boxes pass through and get clustered into one or more objects, we
can still look at the area where the box locations are and set some sort of
threshold to reject clusters where the proposal locations are spread over too
wide an area.

This is of course a work in progress.  I'm sure the plan will continue to evolve
as we run into problems or think of things we hadn't thought of before.

28 Jan 15

--Stopped working on EKFMonoSLAM because it started to look like the
  effort/reward ratio for using their code would not be worth it.  I think I can
  get roughly half the effect of their code by using the code Dan and I
  developed to project from pixel location to world
  location. (source/rover-projection.sc) 

--Resuming work on robottest.m to unite the projection stuff in Scheme with the
  proposal and similarity stuff from MATLAB.

--Using the assumption that all proposal boxes are on the ground plane, our code
  can find the distance of a pixel from the cam, and with the odometry can turn
  that into a world location.  We know this assumption is not valid in all
  cases, but it should be the case that proposal boxes that are actually above
  the ground plane will get distances that are farther away from the camera.
  Since we know the boundaries of our driving area, we can exclude boxes that
  have locations outside the boundaries.

--From there, we can establish 3 similarity measures:
       1) Visual similarity (should be the default for current methods).
       2) Location similarity (from location determined as above).
       3) Object size similarity--We can compute the world height and width of a
       box once we know its distance from the camera.  The idea is that boxes
       that surround the same object should have a similar size.

--Use these 3 similarity measures in the graphical model formulation.  This
  should allow us to group boxes in successive frames into clusters that
  represent an object.  We can then use some sort of average (weighted somehow?)
  of the box locations to determine object location.

--May also have a lot of proposal boxes that detect the ground right in front of
  the rover.  These will probably not get rejected based on distance because
  they will be in bounds.  Visual similarity of these might be high, but
  location similarity may be low, and size similarity most likely will be low.
  Should these proposals cluster into an object anyways, we can look at the area
  over which the locations are distributed and set some sort of threshold to
  eliminate clusters spread over too wide an area.

-----------------git commit e46b217----------------

29 Jan 15

--Modified log_to_track.cpp (in vader-rover/position) to have estimates inserted
  with original sensor readings.  Need this so that the timing info in the
  sensors is preserved, so that we can associate a time with a position
  estimate.  Then we can use the times to link a frame to a position.

--***WILL NEED TO USE THIS TO PRODUCE imu-log-with-estimates.txt FOR DATA ON
     MANUALLY DRIVEN RUNS****

--Have the reading of the position estimates (with time) is working from
  imu-log-with-estimates.txt.  Should also work with imu-log.txt produced from
  autodrive (have not tested this yet).  Next step is to match frames to
  positions using the time data.

-----------------git commit 7232960----------------

30 Jan 15

--Have frames matched with position using time data.  For test data, the mean
  difference between frame time and position time is 0.97ms, with a max of
  around 2 ms.  This should be good.

--Working with just 2 images for now (frames 21 and 22) that are temporally
  adjacent and have the cone prominent in them.

--Jeff gave me the idea to use optical flow between frames for reprojecting
  proposals.  See email dated 30Jan15.  Email has C code to do this.  Found some
  MATLAB code (flow_code.zip) that claims to do similar stuff--need to check
  this out more.

--Also need to put camera calibration stuff into MATLAB to do projection of
  boxes into world coordinates.

--Talking with Dan and recognized the need to get at least a very simple dummy
  GM solver built (with MATLAB-scheme-C glue) in order to test out how it all
  will work together.  Look at code in ~/codetection/opengm.

----------------git commit 6484f48----------------

5 Feb 15

--Started working with Haonan's updated sentence-codetection code.  It's
  currently built to be a stand-alone executable, but I think for my purposes it
  would be better to have it built into DSCI so that I can call its functions
  from the interpreter.  Going to look at how to compile it in, similar to how I
  compiled in the stuff for the rover.  The goal of this part is to be able to
  get the results of the GM solver (from C++) back into Scheme in order to use
  Scheme to visualize the boxes.

--Still working on getting codetection.sc (now called toollib-codetection.sc) to
  compile into DSCI.  Getting compilation errors with duplicate
  definitions--need to go through and resolve those.

----------------git commit 77c1855----------------

6 Feb 15

--Got toollib-codetection.sc compiled into DSCI.  Had to comment out most of
  codetectionlib-c.{c,h} because of conflicts with idealib-c.  Seems to be
  working now.  Next step is to figure out how to load up my video (or a subset
  of frames), run the GM solver, and visualize the output.

--Have video loading, frame subset selection, and box drawing and visualization
  working.  Next step is to look at how the GM is formulated and see about
  adding classes.

----------------git commit d94100b----------------

11 Feb 15

--Have box->world projection working. It eliminates both boxes that are outside
  of boundaries as well as those that plot behind the camera (i.e., ones above
  ground plane).  First test has 100 original boxes going down to 39 valid
  boxes.

--Next thought is to look at doing some sort of clustering based on box
  locations.  General idea is to use a triangular or gaussian function with a
  certain radius to build a count for each box based off the distance from that
  box to the others (function value at that distance).  This might be suitable
  for forming a new score for the box.

----------------git commit 1348533----------------

12 Feb 15

--Have unary scoring function based on distance between a box and all other
  boxes.  This distance is used as an input to gaussmf (parameters are sigma=.25
  and mu=0) to get a score (higher=better) for that neighbor.  These are summed
  and then divided by the total number of proposals generated (top_k).  This
  score seems to be a big improvement over old proposal score.  Testing with 2
  frames (1 w/obj, 1 w/o) showed 39 valid boxes with scores max=.1689,
  mean=.0982 for object, 9 valid boxes with scores max=.0382, mean=.0243 for no
  object.  Need to think about how to incorporate--replace old score or do a
  linear combination with some multipliers?  Also, can we use some of this info
  to figure out a way to enable the "dummy" state?

--Need to finish implementing this as a plug-in function to the existing Scheme
  code.  Want to try it as a comparison against the original codetection.  Need
  to figure out how to get frame times/locations synced up with video outside of
  MATLAB-->Dan's code already does this, so need to adapt and use.

--Also want to think about adding to the binary (similarity) score.  The one
  Haonan uses seems pretty good, but I might be able to improve on it.  Two easy
  ones are to compare the world location and world width of boxes.  Can compute
  that easily from the data I have now.  Can't quite figure out how to do the
  world height of the box though, so can't do area so easily.

--Jeff also suggested using other scores, like distance from center of frame
  (unary), optical flow (binary or unary???), and using pb or region contour
  (??) edge detector within the box.  Not sure how to implement the last 2.

--Want to focus on running the full detector on the shortened video in
  training-videos/short (with corresponding video_front.txt and
  imu-log-with-estimates.txt).  This is 18 frames of the cone being in the
  frame.

----------------git commit 470062b----------------
 
13 Feb 15

--Have function in Scheme to align poses with frames.  Need to finish writing
  scott-run-codetection-full-video and corresponding MATLAB function to do
  different computations.  Want to do a linear combination of original proposal
  score, my gaussian distance score, and maybe another gaussian distance score
  based on distance from center of frame.  Later, look at doing a unary optical
  flow score to compare whole frame's average flow to box's avg flow-->look at
  computing using scheme->c bindings and then passing the result into MATLAB.

--Also want to relook binary scores, such as flow between boxes in subsequent
  frames, world distance between boxes, world box width (height is a problem),
  etc.  Jeff also talked about doing binary scores between all frames (not just
  subsequent ones), but can't quite wrap my head around that yet.

----------------git commit 15011c3----------------

16 Feb 15

--Started looking at Multiscale Combinatorial Grouping (arbelaez2014multiscale)
  paper and associated code in source/sentence-codetection/MCG-PreTrained.
  General idea is to have this code output a contour map for each frame and then
  compare box proposals to contour map.  

  Not exactly sure how to do comparison--could we compare area of box to area of
  contour within box?  How to compute this? Also, need a way to prevent tiny
  boxes that are completely inside contour from getting high score.

--Want to use gaussian distance measure as a unary score across multiple
  images.  Have first try at this implemented in
  source/sentence-codetection/scott_proposals_similarity.m.  Had trouble with
  calls to matlabpool() this afternoon--license wasn't available.  Need to try
  again later. 

******Look at saliency score for image/boxes as a substitute for f (proposal)
      score.  saliency.mit.edu
****Can look at using a comparison between some metric inside the box and
      outside the box (or over the whole frame) to get a better proposal score.
      First thought is to use average color.  Can find average color in each of
      the 3 channels and then treat as a 3-vector and compute distance.  Bigger
      distance = better score.  Could also use some different metric.
****Consider optical flow as well.  Can find optical flow for whole image,
      average it, subtract out the average, and then look at the optical flow
      inside the proposal box.

Looking at using a combination of saliency and average color to build a new
unary score.--Current similarity measure seems to do a good job selecting
consistent boxes, but which track wins depends on unary proposal score, which
doesn't seem very good.

First want to do distance/location measure on each box to reject boxes outside
of boundaries (before sending to similarity measure).  Then can also use
dist/loc as a factor for similarity.

Seem to be getting different boxes when I pull image off of avi file vs. loading
png of frame--not sure why that is.  Make sure the frame is actually the same
one.  Have checked, and isequal(im1,im2) returns 0.  Is this even important?????
